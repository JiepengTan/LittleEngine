#pragma once
{{#include_headfiles}}
#include "{{headfile_name}}"
{{/include_headfiles}}

{{#class_defines}}
namespace {{class_namespace}}{
    TypeID {{class_name}}::MetaTypeId = {{class_type_id}};
    {{#class_is_struct}}struct {{class_name}}; {{/class_is_struct}}{{^class_is_struct}}class {{class_name}}; {{/class_is_struct}}
    std::string {{class_name}}::ToString(){ return ToJson().dump();}
    Json {{class_name}}::ToJson(){ return LittleEngine::JsonSerializer::Write(*this);}
}
{{/class_defines}}

{{#class_defines}}
namespace {{class_namespace}}::MetaCodeGen{
    class TypeOperator_{{class_name}}{
    public:
        static const char* GetClassName(){ return "{{class_name}}";}
        static void* ConstructorWithJson(const Json& jsonContext){
            {{class_name}}* ret_instance= new {{class_name}};
            LittleEngine::JsonSerializer::Read(jsonContext, *ret_instance);
            return ret_instance;
        }
        static Json WriteByName(void* instance){
            return LittleEngine::JsonSerializer::Write(*({{class_name}}*)instance);
        }
        
        static bool IsAbstract(){ return {{class_is_abstract}} ;}

        static std::vector<TypeID> GetBaseClassIds(){
            std::vector<TypeID> baseIds ;
            {{#class_base_class_defines}}baseIds.push_back({{class_base_class_name}}::MetaTypeId); {{/class_base_class_defines}}
            return baseIds;
        };
        static void* ConstructorNew(){
            return new {{class_name}};
        }
        

        // fields
        {{#class_field_defines}}
        
        static void Set_{{class_field_name}}(void* instance, void* field_value){ 
            {{#class_field_is_array}}memcpy(&static_cast<{{class_name}}*>(instance)->{{class_field_name}},field_value,sizeof({{class_name}}::{{class_field_name}}));{{/class_field_is_array}}
            {{#class_field_is_vector}}memcpy(&static_cast<{{class_name}}*>(instance)->{{class_field_name}},field_value,sizeof({{class_name}}::{{class_field_name}}));{{/class_field_is_vector}}
            {{#class_field_is_not_container}}static_cast<{{class_name}}*>(instance)->{{class_field_name}} = *static_cast<{{{class_field_type}}}*>(field_value);{{/class_field_is_not_container}} 
         }
        static void* Get_{{class_field_name}}(void* instance){ return static_cast<void*>(&(static_cast<{{class_name}}*>(instance)->{{class_field_name}}));}
        static const char* GetFieldName_{{class_field_name}}(){ return "{{class_field_name}}";}
        static const char* GetFieldTypeName_{{class_field_name}}(){ return "{{{class_field_type}}}";}
        static bool IsVector_{{class_field_name}}(){ {{#class_field_is_vector}}return true;{{/class_field_is_vector}}{{^class_field_is_vector}}return false;{{/class_field_is_vector}} }
        static bool IsArray_{{class_field_name}}(){ {{#class_field_is_array}}return true;{{/class_field_is_array}}{{^class_field_is_array}}return false;{{/class_field_is_array}} }
        {{/class_field_defines}}

        // methods
        {{#class_method_defines}}
        static const char* GetMethodName_{{class_method_name}}(){ return "{{class_method_name}}";}
        static void Invoke_{{class_method_name}}(void * instance){static_cast<{{class_name}}*>(instance)->{{class_method_name}}();}
        {{/class_method_defines}}
    };

{{#vector_exist}}
    {{#vector_defines}}
#ifndef ArrayOperator_{{vector_useful_name}}MACRO
#define ArrayOperator_{{vector_useful_name}}MACRO
    class ArrayOperator_{{vector_useful_name}}{
        public:
            static const char* GetArrayTypeName(){ return "{{{vector_type_name}}}";}
            static const char* GetElementTypeName(){ return "{{{vector_element_type_name}}}";}
            static int GetSize(void* instance){
                //todo: should check validation
                return static_cast<int>(static_cast<{{{vector_type_name}}}*>(instance)->size());
            }
            static void* Get(int index,void* instance){
                //todo: should check validation
                return static_cast<void*>(&((*static_cast<{{{vector_type_name}}}*>(instance))[index]));
            }
            static void Set(int index, void* instance, void* element_value){
                //todo: should check validation
                (*static_cast<{{{vector_type_name}}}*>(instance))[index] = *static_cast<{{{vector_element_type_name}}}*>(element_value);
            }
    };
#endif ArrayOperator_{{vector_useful_name}}MACRO
    {{/vector_defines}}
{{/vector_exist}}

}
{{/class_defines}}

 {{#class_defines}}
 namespace {{class_namespace}}::MetaCodeGen{
    void TypeWrapperRegister_{{class_name}}(){
        // register field info
        {{#class_field_defines}}
        LittleEngine::Reflection::FieldFunctionTuple* field_function_tuple_{{class_field_name}}=new LittleEngine::Reflection::FieldFunctionTuple{
            &TypeOperator_{{class_name}}::Set_{{class_field_name}},
            &TypeOperator_{{class_name}}::Get_{{class_field_name}},
            &TypeOperator_{{class_name}}::GetClassName,
            &TypeOperator_{{class_name}}::GetFieldName_{{class_field_name}},
            &TypeOperator_{{class_name}}::GetFieldTypeName_{{class_field_name}},
            &TypeOperator_{{class_name}}::IsArray_{{class_field_name}}
            };
        META_REGISTER_FIELD_TO_MAP("{{class_name}}", field_function_tuple_{{class_field_name}});
        {{/class_field_defines}}

        // register function info
        {{#class_method_defines}}
        LittleEngine::Reflection::MethodFunctionTuple* method_function_tuple_{{class_method_name}}=new LittleEngine::Reflection::MethodFunctionTuple{
            &TypeOperator_{{class_name}}::GetMethodName_{{class_method_name}},
            &TypeOperator_{{class_name}}::Invoke_{{class_method_name}});
        META_REGISTER_Method_TO_MAP("{{class_name}}", method_function_tuple_{{class_method_name}}
        };
        {{/class_method_defines}}

        // register array info
    {{#vector_exist}}
        {{#vector_defines}}
        LittleEngine::Reflection::ArrayFunctionTuple* array_tuple_{{vector_useful_name}} = new LittleEngine::Reflection::ArrayFunctionTuple{
            &ArrayOperator_{{vector_useful_name}}::Set,
            &ArrayOperator_{{vector_useful_name}}::Get,
            &ArrayOperator_{{vector_useful_name}}::GetSize,
            &ArrayOperator_{{vector_useful_name}}::GetArrayTypeName,
            &ArrayOperator_{{vector_useful_name}}::GetElementTypeName
         };
        META_REGISTER_ARRAY_TO_MAP("{{{vector_type_name}}}", array_tuple_{{vector_useful_name}});
        {{/vector_defines}}
    {{/vector_exist}}

        // register class type info
        {{#class_need_register}}
        LittleEngine::Reflection::ClassFunctionTuple* class_function_tuple_{{class_name}}=new LittleEngine::Reflection::ClassFunctionTuple{
            &TypeOperator_{{class_name}}::ConstructorWithJson,
            &TypeOperator_{{class_name}}::WriteByName,
            &TypeOperator_{{class_name}}::GetBaseClassIds,
            &TypeOperator_{{class_name}}::ConstructorNew,
            &TypeOperator_{{class_name}}::IsAbstract
              };
        META_REGISTER_BASE_CLASS_TO_MAP("{{class_name}}", class_function_tuple_{{class_name}}, {{class_type_id}});
        {{/class_need_register}}
    }
}
{{/class_defines}}


namespace LittleEngine::Reflection::TypeWrappersRegister{
    void {{sourefile_name_upper_camel_case}}()
    {
    {{#class_defines}} 
        {{class_namespace}}::MetaCodeGen::TypeWrapperRegister_{{class_name}}();
    {{/class_defines}}
    }
}

